Reinforcement learning (RL) is an area of machine learning concerned with how software agents ought to take actions in an environment in order to maximize the notion of cumulative reward. Reinforcement learning is one of three basic machine learning paradigms, alongside supervised learning and unsupervised learning.\nReinforcement learning differs from supervised learning in not needing labelled input/output pairs be presented, and in not needing sub-optimal actions to be explicitly corrected. Instead the focus is on finding a balance between exploration (of uncharted territory) and exploitation (of current knowledge).\nThe environment is typically stated in the form of a Markov decision process (MDP), because many reinforcement learning algorithms for this context utilize dynamic programming techniques. The main difference between the classical dynamic programming methods  and reinforcement learning algorithms is that the latter do not assume knowledge of an exact mathematical model of the MDP and they target large MDPs where exact methods become infeasible.\n\n\n== Introduction ==\n\nReinforcement learning, due to its generality, is studied in many other disciplines, such as game theory, control theory, operations research, information theory, simulation-based optimization, multi-agent systems, swarm intelligence, statistics and genetic algorithms. In the operations research and control literature, reinforcement learning is called approximate dynamic programming, or neuro-dynamic programming. The problems of interest in reinforcement learning have also been studied in the theory of optimal control, which is concerned mostly with the existence and characterization of optimal solutions, and algorithms for their exact computation, and less with learning or approximation, particularly in the absence of a mathematical model of the environment. In economics and game theory, reinforcement learning may be used to explain how equilibrium may arise under bounded rationality.\nBasic reinforcement is modeled as a Markov decision process:\n\na set of environment and agent states, S;\na set of actions, A, of the agent;\n\n  \n    \n      \n        \n          P\n          \n            a\n          \n        \n        (\n        s\n        ,\n        \n          s\n          \u2032\n        \n        )\n        =\n        Pr\n        (\n        \n          s\n          \n            t\n            +\n            1\n          \n        \n        =\n        \n          s\n          \u2032\n        \n        \u2223\n        \n          s\n          \n            t\n          \n        \n        =\n        s\n        ,\n        \n          a\n          \n            t\n          \n        \n        =\n        a\n        )\n      \n    \n    {\\displaystyle P_{a}(s,s')=\\Pr(s_{t+1}=s'\\mid s_{t}=s,a_{t}=a)}\n   is the probability of transition (at time \n  \n    \n      \n        t\n      \n    \n    {\\displaystyle t}\n  ) from state \n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n   to state \n  \n    \n      \n        \n          s\n          \u2032\n        \n      \n    \n    {\\displaystyle s'}\n   under action \n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  .\n\n  \n    \n      \n        \n          R\n          \n            a\n          \n        \n        (\n        s\n        ,\n        \n          s\n          \u2032\n        \n        )\n      \n    \n    {\\displaystyle R_{a}(s,s')}\n   is the immediate reward after transition from \n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n   to \n  \n    \n      \n        \n          s\n          \u2032\n        \n      \n    \n    {\\displaystyle s'}\n   with action \n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  .\nrules that describe what the agent observesRules are often stochastic. The observation typically involves the scalar, immediate reward associated with the last transition. In many works, the agent is assumed to observe the current environmental state (full observability). If not, the agent has partial observability. Sometimes the set of actions available to the agent is restricted (a zero balance cannot be reduced. For example, if the current value of the agent is 3 and the state transition reduces the value by 4, the transition will not be allowed).\nA reinforcement learning agent interacts with its environment in discrete time steps. At each time t, the agent receives an observation \n  \n    \n      \n        \n          o\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle o_{t}}\n  , which typically includes the reward \n  \n    \n      \n        \n          r\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle r_{t}}\n  . It then chooses an action \n  \n    \n      \n        \n          a\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle a_{t}}\n   from the set of available actions, which is subsequently sent to the environment. The environment moves to a new state \n  \n    \n      \n        \n          s\n          \n            t\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle s_{t+1}}\n   and the reward \n  \n    \n      \n        \n          r\n          \n            t\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle r_{t+1}}\n   associated with the transition \n  \n    \n      \n        (\n        \n          s\n          \n            t\n          \n        \n        ,\n        \n          a\n          \n            t\n          \n        \n        ,\n        \n          s\n          \n            t\n            +\n            1\n          \n        \n        )\n      \n    \n    {\\displaystyle (s_{t},a_{t},s_{t+1})}\n   is determined. The goal of a reinforcement learning agent is to collect as much reward as possible. The agent can (possibly randomly) choose any action as a function of the history.\nWhen the agent's performance is compared to that of an agent that acts optimally, the difference in performance gives rise to the notion of regret. In order to act near optimally, the agent must reason about the long-term consequences of its actions (i.e., maximize future income), although the immediate reward associated with this might be negative.\nThus, reinforcement learning is particularly well-suited to problems that include a long-term versus short-term reward trade-off. It has been applied successfully to various problems, including robot control, elevator scheduling, telecommunications, backgammon, checkers and Go (AlphaGo).\nTwo elements make reinforcement learning powerful: the use of samples to optimize performance and the use of function approximation to deal with large environments. Thanks to these two key components, reinforcement learning can be used in large environments in the following situations:\n\nA model of the environment is known, but an analytic solution is not available;\nOnly a simulation model of the environment is given (the subject of simulation-based optimization);\nThe only way to collect information about the environment is to interact with it.The first two of these problems could be considered planning problems (since some form of model is available), while the last one could be considered to be a genuine learning problem. However, reinforcement learning converts both planning problems to machine learning problems.\n\n\n== Exploration ==\nThe exploration vs. exploitation trade-off has been most thoroughly studied through the multi-armed bandit problem and for finite state space MDPs in Burnetas and Katehakis (1997).Reinforcement learning requires clever exploration mechanisms; randomly selecting actions, without reference to an estimated probability distribution, shows poor performance. The case of (small) finite Markov decision processes is relatively well understood. However, due to the lack of algorithms that scale well with the number of states (or scale to problems with infinite state spaces), simple exploration methods are the most practical.\nOne such method is \n  \n    \n      \n        \u03f5\n      \n    \n    {\\displaystyle \\epsilon }\n  -greedy, where \n  \n    \n      \n        0\n        <\n        \u03f5\n        <\n        1\n      \n    \n    {\\displaystyle 0<\\epsilon <1}\n   is a parameter controlling the amount of exploration vs. exploitation.  With probability \n  \n    \n      \n        1\n        \u2212\n        \u03f5\n      \n    \n    {\\displaystyle 1-\\epsilon }\n  , exploitation is chosen, and the agent chooses the action that it believes has the best long-term effect (ties between actions are broken uniformly at random). Alternatively, with probability \n  \n    \n      \n        \u03f5\n      \n    \n    {\\displaystyle \\epsilon }\n  , exploration is chosen, and the action is chosen uniformly at random. \n  \n    \n      \n        \u03f5\n      \n    \n    {\\displaystyle \\epsilon }\n   is usually a fixed parameter but can be adjusted either according to a schedule (making the agent explore progressively less), or adaptively based on heuristics.\n\n\n== Algorithms for control learning ==\nEven if the issue of exploration is disregarded and even if the state was observable (assumed hereafter), the problem remains to use past experience to find out which actions lead to higher cumulative rewards.\n\n\n=== Criterion of optimality ===\n\n\n==== Policy ====\nThe agent's action selection is modeled as a map called policy:\n\n  \n    \n      \n        \u03c0\n        :\n        A\n        \xd7\n        S\n        \u2192\n        [\n        0\n        ,\n        1\n        ]\n      \n    \n    {\\displaystyle \\pi :A\\times S\\rightarrow [0,1]}\n  \n\n  \n    \n      \n        \u03c0\n        (\n        a\n        ,\n        s\n        )\n        =\n        Pr\n        (\n        \n          a\n          \n            t\n          \n        \n        =\n        a\n        \u2223\n        \n          s\n          \n            t\n          \n        \n        =\n        s\n        )\n      \n    \n    {\\displaystyle \\pi (a,s)=\\Pr(a_{t}=a\\mid s_{t}=s)}\n  The policy map gives the probability of taking action \n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n   when in state \n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  . There are also non-probabilistic policies.\n\n\n==== State-value function ====\nValue function \n  \n    \n      \n        \n          V\n          \n            \u03c0\n          \n        \n        (\n        s\n        )\n      \n    \n    {\\displaystyle V_{\\pi }(s)}\n   is defined as the expected return starting with state \n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  , i.e. \n  \n    \n      \n        \n          s\n          \n            0\n          \n        \n        =\n        s\n      \n    \n    {\\displaystyle s_{0}=s}\n  , and successively following policy \n  \n    \n      \n        \u03c0\n      \n    \n    {\\displaystyle \\pi }\n  . Hence, roughly speaking, the value function estimates "how good" it is to be in a given state.\n\n  \n    \n      \n        \n          V\n          \n            \u03c0\n          \n        \n        (\n        s\n        )\n        =\n        E\n        \u2061\n        [\n        R\n        ]\n        =\n        E\n        \u2061\n        \n          [\n          \n            \n              \u2211\n              \n                t\n                =\n                0\n              \n              \n                \u221e\n              \n            \n            \n              \u03b3\n              \n                t\n              \n            \n            \n              r\n              \n                t\n              \n            \n            \u2223\n            \n              s\n              \n                0\n              \n            \n            =\n            s\n          \n          ]\n        \n        ,\n      \n    \n    {\\displaystyle V_{\\pi }(s)=\\operatorname {E} [R]=\\operatorname {E} \\left[\\sum _{t=0}^{\\infty }\\gamma ^{t}r_{t}\\mid s_{0}=s\\right],}\n  where the random variable \n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n   denotes the return, and is defined as the sum of future discounted rewards (gamma is less than 1, as a particular state becomes older, its effect on the later states becomes less and less. Thus, we discount its effect).\n\n  \n    \n      \n        R\n        =\n        \n          \u2211\n          \n            t\n            =\n            0\n          \n          \n            \u221e\n          \n        \n        \n          \u03b3\n          \n            t\n          \n        \n        \n          r\n          \n            t\n          \n        \n        ,\n      \n    \n    {\\displaystyle R=\\sum _{t=0}^{\\infty }\\gamma ^{t}r_{t},}\n  where \n  \n    \n      \n        \n          r\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle r_{t}}\n   is the reward at step \n  \n    \n      \n        t\n      \n    \n    {\\displaystyle t}\n  , \n  \n    \n      \n        \u03b3\n        \u2208\n        [\n        0\n        ,\n        1\n        )\n      \n    \n    {\\displaystyle \\gamma \\in [0,1)}\n   is the discount-rate.\nThe algorithm must find a policy with maximum expected return. From the theory of MDPs it is known that, without loss of generality, the search can be restricted to the set of so-called stationary policies. A policy is stationary if the action-distribution returned by it depends only on the last state visited (from the observation agent's history). The search can be further restricted to deterministic stationary policies. A deterministic stationary policy deterministically selects actions based on the current state. Since any such policy can be identified with a mapping from the set of states to the set of actions, these policies can be identified with such mappings with no loss of generality.\n\n\n=== Brute force ===\nThe brute force approach entails two steps:\n\nFor each possible policy, sample returns while following it\nChoose the policy with the largest expected returnOne problem with this is that the number of policies can be large, or even infinite. Another is that variance of the returns may be large, which requires many samples to accurately estimate the return of each policy.\nThese problems can be ameliorated if we assume some structure and allow samples generated from one policy to influence the estimates made for others. The two main approaches for achieving this are value function estimation and direct policy search.\n\n\n=== Value function ===\n\nValue function approaches attempt to find a policy that maximizes the return by maintaining a set of estimates of expected returns for some policy (usually either the "current" [on-policy] or the optimal [off-policy] one).\nThese methods rely on the theory of MDPs, where optimality is defined in a sense that is stronger than the above one: A policy is called optimal if it achieves the best expected return from any initial state (i.e., initial distributions play no role in this definition). Again, an optimal policy can always be found amongst stationary policies.\nTo define optimality in a formal manner, define the value of a policy \n  \n    \n      \n        \u03c0\n      \n    \n    {\\displaystyle \\pi }\n   by\n\n  \n    \n      \n        \n          V\n          \n            \u03c0\n          \n        \n        (\n        s\n        )\n        =\n        E\n        [\n        R\n        \u2223\n        s\n        ,\n        \u03c0\n        ]\n        ,\n      \n    \n    {\\displaystyle V^{\\pi }(s)=E[R\\mid s,\\pi ],}\n  where \n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n   stands for the return associated with following \n  \n    \n      \n        \u03c0\n      \n    \n    {\\displaystyle \\pi }\n   from the initial state \n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  . Defining \n  \n    \n      \n        \n          V\n          \n            \u2217\n          \n        \n        (\n        s\n        )\n      \n    \n    {\\displaystyle V^{*}(s)}\n   as the maximum possible value of \n  \n    \n      \n        \n          V\n          \n            \u03c0\n          \n        \n        (\n        s\n        )\n      \n    \n    {\\displaystyle V^{\\pi }(s)}\n  , where \n  \n    \n      \n        \u03c0\n      \n    \n    {\\displaystyle \\pi }\n   is allowed to change,\n\n  \n    \n      \n        \n          V\n          \n            \u2217\n          \n        \n        (\n        s\n        )\n        =\n        \n          max\n          \n            \u03c0\n          \n        \n        \n          V\n          \n            \u03c0\n          \n        \n        (\n        s\n        )\n        .\n      \n    \n    {\\displaystyle V^{*}(s)=\\max _{\\pi }V^{\\pi }(s).}\n  A policy that achieves these optimal values in each state is called optimal. Clearly, a policy that is optimal in this strong sense is also optimal in the sense that it maximizes the expected return \n  \n    \n      \n        \n          \u03c1\n          \n            \u03c0\n          \n        \n      \n    \n    {\\displaystyle \\rho ^{\\pi }}\n  , since \n  \n    \n      \n        \n          \u03c1\n          \n            \u03c0\n          \n        \n        =\n        E\n        [\n        \n          V\n          \n            \u03c0\n          \n        \n        (\n        S\n        )\n        ]\n      \n    \n    {\\displaystyle \\rho ^{\\pi }=E[V^{\\pi }(S)]}\n  , where \n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n   is a state randomly sampled from the distribution \n  \n    \n      \n        \u03bc\n      \n    \n    {\\displaystyle \\mu }\n  .\nAlthough state-values suffice to define optimality, it is useful to define action-values. Given a state \n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  , an action \n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n   and a policy \n  \n    \n      \n        \u03c0\n      \n    \n    {\\displaystyle \\pi }\n  , the action-value of the pair \n  \n    \n      \n        (\n        s\n        ,\n        a\n        )\n      \n    \n    {\\displaystyle (s,a)}\n   under \n  \n    \n      \n        \u03c0\n      \n    \n    {\\displaystyle \\pi }\n   is defined by\n\n  \n    \n      \n        \n          Q\n          \n            \u03c0\n          \n        \n        (\n        s\n        ,\n        a\n        )\n        =\n        E\n        \u2061\n        [\n        R\n        \u2223\n        s\n        ,\n        a\n        ,\n        \u03c0\n        ]\n        ,\n        \n      \n    \n    {\\displaystyle Q^{\\pi }(s,a)=\\operatorname {E} [R\\mid s,a,\\pi ],\\,}\n  where \n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n   now stands for the random return associated with first taking action \n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n   in state \n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n   and following \n  \n    \n      \n        \u03c0\n      \n    \n    {\\displaystyle \\pi }\n  , thereafter.\nThe theory of MDPs states that if \n  \n    \n      \n        \n          \u03c0\n          \n            \u2217\n          \n        \n      \n    \n    {\\displaystyle \\pi ^{*}}\n   is an optimal policy, we act optimally (take the optimal action) by choosing the action from \n  \n    \n      \n        \n          Q\n          \n            \n              \u03c0\n              \n                \u2217\n              \n            \n          \n        \n        (\n        s\n        ,\n        \u22c5\n        )\n      \n    \n    {\\displaystyle Q^{\\pi ^{*}}(s,\\cdot )}\n   with the highest value at each state, \n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  . The action-value function of such an optimal policy (\n  \n    \n      \n        \n          Q\n          \n            \n              \u03c0\n              \n                \u2217\n              \n            \n          \n        \n      \n    \n    {\\displaystyle Q^{\\pi ^{*}}}\n  ) is called the optimal action-value function and is commonly denoted by \n  \n    \n      \n        \n          Q\n          \n            \u2217\n          \n        \n      \n    \n    {\\displaystyle Q^{*}}\n  . In summary, the knowledge of the optimal action-value function alone suffices to know how to act optimally.\nAssuming full knowledge of the MDP, the two basic approaches to compute the optimal action-value function are value iteration and policy iteration. Both algorithms compute a sequence of functions \n  \n    \n      \n        \n          Q\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle Q_{k}}\n   (\n  \n    \n      \n        k\n        =\n        0\n        ,\n        1\n        ,\n        2\n        ,\n        \u2026\n      \n    \n    {\\displaystyle k=0,1,2,\\ldots }\n  ) that converge to \n  \n    \n      \n        \n          Q\n          \n            \u2217\n          \n        \n      \n    \n    {\\displaystyle Q^{*}}\n  . Computing these functions involves computing expectations over the whole state-space, which is impractical for all but the smallest (finite) MDPs. In reinforcement learning methods, expectations are approximated by averaging over samples and using function approximation techniques to cope with the need to represent value functions over large state-action spaces.\n\n\n==== Monte Carlo methods ====\nMonte Carlo methods can be used in an algorithm that mimics policy iteration. Policy iteration consists of two steps: policy evaluation and policy improvement.\nMonte Carlo is used in the policy evaluation step. In this step, given a stationary, deterministic policy \n  \n    \n      \n        \u03c0\n      \n    \n    {\\displaystyle \\pi }\n  , the goal is to compute the function values \n  \n    \n      \n        \n          Q\n          \n            \u03c0\n          \n        \n        (\n        s\n        ,\n        a\n        )\n      \n    \n    {\\displaystyle Q^{\\pi }(s,a)}\n   (or a good approximation to them) for all state-action pairs \n  \n    \n      \n        (\n        s\n        ,\n        a\n        )\n      \n    \n    {\\displaystyle (s,a)}\n  . Assuming (for simplicity) that the MDP is finite, that sufficient memory is available to accommodate the action-values and that the problem is episodic and after each episode a new one starts from some random initial state. Then, the estimate of the value of a given state-action pair \n  \n    \n      \n        (\n        s\n        ,\n        a\n        )\n      \n    \n    {\\displaystyle (s,a)}\n   can be computed by averaging the sampled returns that originated from \n  \n    \n      \n        (\n        s\n        ,\n        a\n        )\n      \n    \n    {\\displaystyle (s,a)}\n   over time.  Given sufficient time, this procedure can thus construct a precise estimate \n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n   of the action-value function \n  \n    \n      \n        \n          Q\n          \n            \u03c0\n          \n        \n      \n    \n    {\\displaystyle Q^{\\pi }}\n  . This finishes the description of the policy evaluation step.\nIn the policy improvement step, the next policy is obtained by computing a greedy policy with respect to \n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  : Given a state \n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  , this new policy returns an action that maximizes \n  \n    \n      \n        Q\n        (\n        s\n        ,\n        \u22c5\n        )\n      \n    \n    {\\displaystyle Q(s,\\cdot )}\n  . In practice lazy evaluation can defer the computation of the maximizing actions to when they are needed.\nProblems with this procedure include:\n\nThe procedure may spend too much time evaluating a suboptimal policy.\nIt uses samples inefficiently in that a long trajectory improves the estimate only of the single state-action pair that started the trajectory.\nWhen the returns along the trajectories have high variance, convergence is slow.\nIt works in episodic problems only;\nIt works in small, finite MDPs only.\n\n\n==== Temporal difference methods ====\n\nThe first problem is corrected by allowing the procedure to change the policy (at some or all states) before the values settle. This too may be problematic as it might prevent convergence. Most current algorithms do this, giving rise to the class of generalized policy iteration algorithms. Many actor critic methods belong to this category.\nThe second issue can be corrected by allowing trajectories to contribute to any state-action pair in them. This may also help to some extent with the third problem, although a better solution when returns have high variance is Sutton's temporal difference (TD) methods that are based on the recursive Bellman equation. The computation in TD methods can be incremental (when after each transition the memory is changed and the transition is thrown away), or batch (when the transitions are batched and the estimates are computed once based on the batch). Batch methods, such as the least-squares temporal difference method, may use the information in the samples better, while incremental methods are the only choice when batch methods are infeasible due to their high computational or memory complexity. Some methods try to combine the two approaches. Methods based on temporal differences also overcome the fourth issue.\nIn order to address the fifth issue, function approximation methods are used. Linear function approximation starts with a mapping \n  \n    \n      \n        \u03d5\n      \n    \n    {\\displaystyle \\phi }\n   that assigns a finite-dimensional vector to each state-action pair. Then, the action values of a state-action pair \n  \n    \n      \n        (\n        s\n        ,\n        a\n        )\n      \n    \n    {\\displaystyle (s,a)}\n   are obtained by linearly combining the components of \n  \n    \n      \n        \u03d5\n        (\n        s\n        ,\n        a\n        )\n      \n    \n    {\\displaystyle \\phi (s,a)}\n   with some weights \n  \n    \n      \n        \u03b8\n      \n    \n    {\\displaystyle \\theta }\n  :\n\n  \n    \n      \n        Q\n        (\n        s\n        ,\n        a\n        )\n        =\n        \n          \u2211\n          \n            i\n            =\n            1\n          \n          \n            d\n          \n        \n        \n          \u03b8\n          \n            i\n          \n        \n        \n          \u03d5\n          \n            i\n          \n        \n        (\n        s\n        ,\n        a\n        )\n        .\n      \n    \n    {\\displaystyle Q(s,a)=\\sum _{i=1}^{d}\\theta _{i}\\phi _{i}(s,a).}\n  The algorithms then adjust the weights, instead of adjusting the values associated with the individual state-action pairs. Methods based on ideas from nonparametric statistics (which can be seen to construct their own features) have been explored.\nValue iteration can also be used as a starting point, giving rise to the Q-learning algorithm and its many variants.The problem with using action-values is that they may need highly precise estimates of the competing action values that can be hard to obtain when the returns are noisy, though this problem is mitigated to some extent by temporal difference methods. Using the so-called compatible function approximation method compromises generality and efficiency. Another problem specific to TD comes from their reliance on the recursive Bellman equation. Most TD methods have a so-called \n  \n    \n      \n        \u03bb\n      \n    \n    {\\displaystyle \\lambda }\n   parameter \n  \n    \n      \n        (\n        0\n        \u2264\n        \u03bb\n        \u2264\n        1\n        )\n      \n    \n    {\\displaystyle (0\\leq \\lambda \\leq 1)}\n   that can continuously interpolate between Monte Carlo methods that do not rely on the Bellman equations and the basic TD methods that rely entirely on the Bellman equations. This can be effective in palliating this issue.\n\n\n=== Direct policy search ===\nAn alternative method is to search directly in (some subset of) the policy space, in which case the problem becomes a case of stochastic optimization. The two approaches available are gradient-based and gradient-free methods.\nGradient-based methods (policy gradient methods) start with a mapping from a finite-dimensional (parameter) space to the space of policies: given the parameter vector \n  \n    \n      \n        \u03b8\n      \n    \n    {\\displaystyle \\theta }\n  , let \n  \n    \n      \n        \n          \u03c0\n          \n            \u03b8\n          \n        \n      \n    \n    {\\displaystyle \\pi _{\\theta }}\n   denote the policy associated to \n  \n    \n      \n        \u03b8\n      \n    \n    {\\displaystyle \\theta }\n  . Defining the performance function by\n\n  \n    \n      \n        \u03c1\n        (\n        \u03b8\n        )\n        =\n        \n          \u03c1\n          \n            \n              \u03c0\n              \n                \u03b8\n              \n            \n          \n        \n        ,\n      \n    \n    {\\displaystyle \\rho (\\theta )=\\rho ^{\\pi _{\\theta }},}\n  under mild conditions this function will be differentiable as a function of the parameter vector \n  \n    \n      \n        \u03b8\n      \n    \n    {\\displaystyle \\theta }\n  . If the gradient of \n  \n    \n      \n        \u03c1\n      \n    \n    {\\displaystyle \\rho }\n   was known, one could use gradient ascent. Since an analytic expression for the gradient is not available, only a noisy estimate is available. Such an estimate can be constructed in many ways, giving rise to algorithms such as Williams' REINFORCE method (which is known as the likelihood ratio method in the simulation-based optimization literature). Policy search methods have been used in the robotics context. Many policy search methods may get stuck in local optima (as they are based on local search).\nA large class of methods avoids relying on gradient information. These include simulated annealing, cross-entropy search or methods of evolutionary computation. Many gradient-free methods can achieve (in theory and in the limit) a global optimum.\nPolicy search methods may converge slowly given noisy data. For example, this happens in episodic problems when the trajectories are long and the variance of the returns is large. Value-function based methods that rely on temporal differences might help in this case. In recent years, actor\u2013critic methods have been proposed and performed well on various problems.\n\n\n== Theory ==\nBoth the asymptotic and finite-sample behavior of most algorithms is well understood. Algorithms with provably good online performance (addressing the exploration issue) are known.\nEfficient exploration of MDPs is given in  Burnetas and Katehakis (1997). Finite-time performance bounds have also appeared for many algorithms, but these bounds are expected to be rather loose and thus more work is needed to better understand the relative advantages and limitations.\nFor incremental algorithms, asymptotic convergence issues have been settled. Temporal-difference-based algorithms converge under a wider set of conditions than was previously possible (for example, when used with arbitrary, smooth function approximation).\n\n\n== Research ==\nResearch topics include \n\nadaptive methods that work with fewer (or no) parameters under a large number of conditions\naddressing the exploration problem in large MDPs\ncombinations with logic-based frameworks\nlarge-scale empirical evaluations\nlearning and acting under partial information (e.g., using predictive state representation)\nmodular and hierarchical reinforcement learning\nimproving existing value-function and policy search methods\nalgorithms that work well with large (or continuous) action spaces\ntransfer learning\nlifelong learning\nefficient sample-based planning (e.g., based on Monte Carlo tree search).\nbug detection in software projects\nIntrinsic motivation which differentiates information-seeking, curiosity-type behaviours from task-dependent goal-directed behaviours (typically) by introducing a reward function based on maximising novel informationMultiagent or distributed reinforcement learning is a topic of interest. Applications are expanding.\nActor-critic reinforcement learningReinforcement learning algorithms such as TD learning are under investigation as a model for dopamine-based learning in the brain. In this model, the dopaminergic projections from the substantia nigra to the basal ganglia function as the prediction error. Reinforcement learning has been used as a part of the model for human skill learning, especially in relation to the interaction between implicit and explicit learning in skill acquisition (the first publication on this application was in 1995\u20131996).\n\n\n== Comparison of reinforcement learning algorithms ==\n\n\n=== Deep reinforcement learning ===\nThis approach extends reinforcement learning by using a deep neural network and without explicitly designing the state space. The work on learning ATARI games by Google DeepMind increased attention to deep reinforcement learning or end-to-end reinforcement learning.\n\n\n=== Inverse reinforcement learning ===\nIn inverse reinforcement learning (IRL), no reward function is given. Instead, the reward function is inferred given an observed behavior from an expert. The idea is to mimic observed behavior, which is often optimal or close to optimal.\n\n\n=== Apprenticeship learning ===\nIn apprenticeship learning, an expert demonstrates the target behavior. The system tries to recover the policy via observation.\n\n\n== See also ==\n\n\n== References ==\n\n\n== Further reading ==\nAuer, Peter; Jaksch, Thomas; Ortner, Ronald (2010). "Near-optimal regret bounds for reinforcement learning". Journal of Machine Learning Research. 11: 1563\u20131600.CS1 maint: ref=harv (link)\nBusoniu, Lucian; Babuska, Robert; De Schutter, Bart; Ernst, Damien (2010). Reinforcement Learning and Dynamic Programming using Function Approximators. Taylor & Francis CRC Press. ISBN 978-1-4398-2108-4.CS1 maint: ref=harv (link)\nFran\xe7ois-Lavet, Vincent; Henderson, Peter; Islam, Riashat; Bellemare, Marc G.; Pineau, Joelle (2018). "An Introduction to Deep Reinforcement Learning". Foundations and Trends in Machine Learning. 11 (3\u20134): 219\u2013354. arXiv:1811.12560. Bibcode:2018arXiv181112560F. doi:10.1561/2200000071.CS1 maint: ref=harv (link)\nPowell, Warren (2007). Approximate dynamic programming: solving the curses of dimensionality. Wiley-Interscience. ISBN 978-0-470-17155-4.CS1 maint: ref=harv (link)\nSutton, Richard S.; Barto, Andrew G. (1998). Reinforcement Learning: An Introduction. MIT Press. ISBN 978-0-262-19398-6.CS1 maint: ref=harv (link)\nSutton, Richard S. (1988). "Learning to predict by the method of temporal differences". Machine Learning. 3: 9\u201344. doi:10.1007/BF00115009.CS1 maint: ref=harv (link)\nSzita, Istvan; Szepesvari, Csaba (2010). "Model-based Reinforcement Learning with Nearly Tight Exploration Complexity Bounds" (PDF). ICML 2010. Omnipress. pp. 1031\u20131038. Archived from the original (PDF) on 2010-07-14.CS1 maint: ref=harv (link)\n\n\n== External links ==\nReinforcement Learning Repository\nReinforcement Learning and Artificial Intelligence (RLAI, Rich Sutton's lab at the University of Alberta)\nAutonomous Learning Laboratory (ALL, Andrew Barto's lab at the University of Massachusetts Amherst)\nHybrid reinforcement learning\nReal-world reinforcement learning experiments at Delft University of Technology\nStanford University Andrew Ng Lecture on Reinforcement Learning\nDissecting Reinforcement Learning Series of blog post on RL with Python code