A multilayer perceptron (MLP) is a class of feedforward artificial neural network (ANN). The term MLP is used ambiguously, sometimes loosely to any feedforward ANN, sometimes strictly to refer to networks composed of multiple layers of perceptrons (with threshold activation); see \xa7 Terminology. Multilayer perceptrons are sometimes colloquially referred to as "vanilla" neural networks, especially when they have a single hidden layer.An MLP consists of at least three layers of nodes: an input layer, a hidden layer and an output layer. Except for the input nodes, each node is a neuron that uses a nonlinear activation function. MLP utilizes a supervised learning technique called backpropagation for training. Its multiple layers and non-linear activation distinguish MLP from a linear perceptron. It can distinguish data that is not linearly separable.\n\n\n== Theory ==\n\n\n=== Activation function ===\nIf a multilayer perceptron has a linear activation function in all neurons, that is, a linear function that maps the weighted inputs to the output of each neuron, then linear algebra shows that any number of layers can be reduced to a two-layer input-output model. In MLPs some neurons use a nonlinear activation function that was developed to model the frequency of action potentials, or firing, of biological neurons.\nThe two historically common activation functions are both sigmoids, and are described by\n\n  \n    \n      \n        y\n        (\n        \n          v\n          \n            i\n          \n        \n        )\n        =\n        tanh\n        \u2061\n        (\n        \n          v\n          \n            i\n          \n        \n        )\n         \n         \n        \n          \n            and\n          \n        \n         \n         \n        y\n        (\n        \n          v\n          \n            i\n          \n        \n        )\n        =\n        (\n        1\n        +\n        \n          e\n          \n            \u2212\n            \n              v\n              \n                i\n              \n            \n          \n        \n        \n          )\n          \n            \u2212\n            1\n          \n        \n      \n    \n    {\\displaystyle y(v_{i})=\\tanh(v_{i})~~{\\textrm {and}}~~y(v_{i})=(1+e^{-v_{i}})^{-1}}\n  .In recent developments of deep learning the rectifier linear unit (ReLU) is more frequently used as one of the possible ways to overcome the numerical problems related to the sigmoids.\nThe first is a hyperbolic tangent that ranges from -1 to 1, while the other is the logistic function, which is similar in shape but ranges from 0 to 1. Here \n  \n    \n      \n        \n          y\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle y_{i}}\n   is the output of the \n  \n    \n      \n        i\n      \n    \n    {\\displaystyle i}\n  th node (neuron) and \n  \n    \n      \n        \n          v\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle v_{i}}\n   is the weighted sum of the input connections. Alternative activation functions have been proposed, including the rectifier and softplus functions. More specialized activation functions include radial basis functions (used in radial basis networks, another class of supervised neural network models).\n\n\n=== Layers ===\nThe MLP consists of three or more layers (an input and an output layer with one or more hidden layers) of nonlinearly-activating nodes. Since MLPs are fully connected, each node in one layer connects with a certain weight \n  \n    \n      \n        \n          w\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle w_{ij}}\n   to every node in the following layer.\n\n\n=== Learning ===\nLearning occurs in the perceptron by changing connection weights after each piece of data is processed, based on the amount of error in the output compared to the expected result. This is an example of supervised learning, and is carried out through backpropagation, a generalization of the least mean squares algorithm in the linear perceptron.\nWe can represent the degree of error in an output node \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n   in the \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  th data point (training example) by \n  \n    \n      \n        \n          e\n          \n            j\n          \n        \n        (\n        n\n        )\n        =\n        \n          d\n          \n            j\n          \n        \n        (\n        n\n        )\n        \u2212\n        \n          y\n          \n            j\n          \n        \n        (\n        n\n        )\n      \n    \n    {\\displaystyle e_{j}(n)=d_{j}(n)-y_{j}(n)}\n  , where \n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n   is the target value and \n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n   is the value produced by the perceptron. The node weights can then be adjusted based on corrections that minimize the error in the entire output, given by\n\n  \n    \n      \n        \n          \n            E\n          \n        \n        (\n        n\n        )\n        =\n        \n          \n            1\n            2\n          \n        \n        \n          \u2211\n          \n            j\n          \n        \n        \n          e\n          \n            j\n          \n          \n            2\n          \n        \n        (\n        n\n        )\n      \n    \n    {\\displaystyle {\\mathcal {E}}(n)={\\frac {1}{2}}\\sum _{j}e_{j}^{2}(n)}\n  .Using gradient descent, the change in each weight is\n\n  \n    \n      \n        \u0394\n        \n          w\n          \n            j\n            i\n          \n        \n        (\n        n\n        )\n        =\n        \u2212\n        \u03b7\n        \n          \n            \n              \u2202\n              \n                \n                  E\n                \n              \n              (\n              n\n              )\n            \n            \n              \u2202\n              \n                v\n                \n                  j\n                \n              \n              (\n              n\n              )\n            \n          \n        \n        \n          y\n          \n            i\n          \n        \n        (\n        n\n        )\n      \n    \n    {\\displaystyle \\Delta w_{ji}(n)=-\\eta {\\frac {\\partial {\\mathcal {E}}(n)}{\\partial v_{j}(n)}}y_{i}(n)}\n  where \n  \n    \n      \n        \n          y\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle y_{i}}\n   is the output of the previous neuron and \n  \n    \n      \n        \u03b7\n      \n    \n    {\\displaystyle \\eta }\n   is the learning rate, which is selected to ensure that the weights quickly converge to a response, without oscillations.\nThe derivative to be calculated depends on the induced local field \n  \n    \n      \n        \n          v\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle v_{j}}\n  , which itself varies. It is easy to prove that for an output node this derivative can be simplified to\n\n  \n    \n      \n        \u2212\n        \n          \n            \n              \u2202\n              \n                \n                  E\n                \n              \n              (\n              n\n              )\n            \n            \n              \u2202\n              \n                v\n                \n                  j\n                \n              \n              (\n              n\n              )\n            \n          \n        \n        =\n        \n          e\n          \n            j\n          \n        \n        (\n        n\n        )\n        \n          \u03d5\n          \n            \u2032\n          \n        \n        (\n        \n          v\n          \n            j\n          \n        \n        (\n        n\n        )\n        )\n      \n    \n    {\\displaystyle -{\\frac {\\partial {\\mathcal {E}}(n)}{\\partial v_{j}(n)}}=e_{j}(n)\\phi ^{\\prime }(v_{j}(n))}\n  where \n  \n    \n      \n        \n          \u03d5\n          \n            \u2032\n          \n        \n      \n    \n    {\\displaystyle \\phi ^{\\prime }}\n   is the derivative of the activation function described above, which itself does not vary. The analysis is more difficult for the change in weights to a hidden node, but it can be shown that the relevant derivative is\n\n  \n    \n      \n        \u2212\n        \n          \n            \n              \u2202\n              \n                \n                  E\n                \n              \n              (\n              n\n              )\n            \n            \n              \u2202\n              \n                v\n                \n                  j\n                \n              \n              (\n              n\n              )\n            \n          \n        \n        =\n        \n          \u03d5\n          \n            \u2032\n          \n        \n        (\n        \n          v\n          \n            j\n          \n        \n        (\n        n\n        )\n        )\n        \n          \u2211\n          \n            k\n          \n        \n        \u2212\n        \n          \n            \n              \u2202\n              \n                \n                  E\n                \n              \n              (\n              n\n              )\n            \n            \n              \u2202\n              \n                v\n                \n                  k\n                \n              \n              (\n              n\n              )\n            \n          \n        \n        \n          w\n          \n            k\n            j\n          \n        \n        (\n        n\n        )\n      \n    \n    {\\displaystyle -{\\frac {\\partial {\\mathcal {E}}(n)}{\\partial v_{j}(n)}}=\\phi ^{\\prime }(v_{j}(n))\\sum _{k}-{\\frac {\\partial {\\mathcal {E}}(n)}{\\partial v_{k}(n)}}w_{kj}(n)}\n  .This depends on the change in weights of the \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  th nodes, which represent the output layer. So to change the hidden layer weights, the output layer weights change according to the derivative of the activation function, and so this algorithm represents a backpropagation of the activation function.\n\n\n== Terminology ==\nThe term "multilayer perceptron" does not refer to a single perceptron that has multiple layers. Rather, it contains many perceptrons that are organized into layers. An alternative is "multilayer perceptron network". Moreover, MLP "perceptrons" are not perceptrons in the strictest possible sense. True perceptrons are formally a special case of artificial neurons that use a threshold activation function such as the Heaviside step function. MLP perceptrons can employ arbitrary activation functions. A true perceptron performs binary classification, an MLP neuron is free to either perform classification or regression, depending upon its activation function.\nThe term "multilayer perceptron" later was applied without respect to nature of the nodes/layers, which can be composed of arbitrarily defined artificial neurons, and not perceptrons specifically. This interpretation avoids the loosening of the definition of "perceptron" to mean an artificial neuron in general.\n\n\n== Applications ==\nMLPs are useful in research for their ability to solve problems stochastically, which often allows approximate solutions for extremely complex problems like fitness approximation.\nMLPs are universal function approximators as shown by Cybenko's theorem, so they can be used to create mathematical models by regression analysis. As classification is a particular case of regression when the response variable is categorical, MLPs make good classifier algorithms.\nMLPs were a popular machine learning solution in the 1980s, finding applications in diverse fields such as speech recognition, image recognition, and machine translation software, but thereafter faced strong competition from much simpler (and related) support vector machines. Interest in backpropagation networks returned due to the successes of deep learning.\n\n\n== References ==\n\n\n== External links ==\nA Gentle Introduction to Backpropagation - An intuitive tutorial by Shashi Sathyanarayana This is an updated PDF version of a blog article that was previously linked here. This article contains pseudocode ("Training Wheels for Training Neural Networks") for implementing the algorithm.\nWeka: Open source data mining software with multilayer perceptron implementation.\nNeuroph Studio documentation, implements this algorithm and a few others.