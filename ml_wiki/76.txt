In computational learning theory, Occam learning is a model of algorithmic learning where the objective of the learner is to output a succinct representation of received training data. This is closely related to probably approximately correct (PAC) learning, where the learner is evaluated on its predictive power of a test set.\nOccam learnability implies PAC learning, and for a wide variety of concept classes, the converse is also true: PAC learnability implies Occam learnability.\n\n\n== Introduction ==\nOccam Learning is named after Occam's razor, which is a principle stating that, given all other things being equal, a shorter explanation for observed data should be favored over a lengthier explanation. The theory of Occam learning is a formal and mathematical justification for this principle. It was first shown by Blumer, et al. that Occam learning implies PAC learning, which is the standard model of learning in computational learning theory. In other words, parsimony (of the output hypothesis) implies predictive power.\n\n\n== Definition of Occam learning ==\nThe succinctness of a concept \n  \n    \n      \n        c\n      \n    \n    {\\displaystyle c}\n   in concept class \n  \n    \n      \n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {C}}}\n   can be expressed by the length \n  \n    \n      \n        s\n        i\n        z\n        e\n        (\n        c\n        )\n      \n    \n    {\\displaystyle size(c)}\n   of the shortest bit string that can represent \n  \n    \n      \n        c\n      \n    \n    {\\displaystyle c}\n   in \n  \n    \n      \n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {C}}}\n  . Occam learning connects the succinctness of a learning algorithm's output to its predictive power on unseen data.\nLet \n  \n    \n      \n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {C}}}\n   and \n  \n    \n      \n        \n          \n            H\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {H}}}\n   be concept classes containing target concepts and hypotheses respectively. Then, for constants \n  \n    \n      \n        \u03b1\n        \u2265\n        0\n      \n    \n    {\\displaystyle \\alpha \\geq 0}\n   and \n  \n    \n      \n        0\n        \u2264\n        \u03b2\n        <\n        1\n      \n    \n    {\\displaystyle 0\\leq \\beta <1}\n  , a learning algorithm \n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n   is an \n  \n    \n      \n        (\n        \u03b1\n        ,\n        \u03b2\n        )\n      \n    \n    {\\displaystyle (\\alpha ,\\beta )}\n  -Occam algorithm for \n  \n    \n      \n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {C}}}\n   using \n  \n    \n      \n        \n          \n            H\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {H}}}\n   iff, given a set \n  \n    \n      \n        S\n        =\n        {\n        \n          x\n          \n            1\n          \n        \n        ,\n        \u2026\n        ,\n        \n          x\n          \n            m\n          \n        \n        }\n      \n    \n    {\\displaystyle S=\\{x_{1},\\dots ,x_{m}\\}}\n   of \n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n   samples labeled according to a concept \n  \n    \n      \n        c\n        \u2208\n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle c\\in {\\mathcal {C}}}\n  , \n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n   outputs a hypothesis \n  \n    \n      \n        h\n        \u2208\n        \n          \n            H\n          \n        \n      \n    \n    {\\displaystyle h\\in {\\mathcal {H}}}\n   such that\n\n  \n    \n      \n        h\n      \n    \n    {\\displaystyle h}\n   is consistent with \n  \n    \n      \n        c\n      \n    \n    {\\displaystyle c}\n   on \n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n   (that is, \n  \n    \n      \n        h\n        (\n        x\n        )\n        =\n        c\n        (\n        x\n        )\n        ,\n        \u2200\n        x\n        \u2208\n        S\n      \n    \n    {\\displaystyle h(x)=c(x),\\forall x\\in S}\n  ), and\n\n  \n    \n      \n        s\n        i\n        z\n        e\n        (\n        h\n        )\n        \u2264\n        (\n        n\n        \u22c5\n        s\n        i\n        z\n        e\n        (\n        c\n        )\n        \n          )\n          \n            \u03b1\n          \n        \n        \n          m\n          \n            \u03b2\n          \n        \n      \n    \n    {\\displaystyle size(h)\\leq (n\\cdot size(c))^{\\alpha }m^{\\beta }}\n   where \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n   is the maximum length of any sample \n  \n    \n      \n        x\n        \u2208\n        S\n      \n    \n    {\\displaystyle x\\in S}\n  . An Occam algorithm is called efficient if it runs in time polynomial in \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  , \n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  , and \n  \n    \n      \n        s\n        i\n        z\n        e\n        (\n        c\n        )\n        .\n      \n    \n    {\\displaystyle size(c).}\n   We say a concept class \n  \n    \n      \n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {C}}}\n   is Occam learnable with respect to a hypothesis class \n  \n    \n      \n        \n          \n            H\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {H}}}\n   if there exists an efficient Occam algorithm for  \n  \n    \n      \n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {C}}}\n   using \n  \n    \n      \n        \n          \n            H\n          \n        \n        .\n      \n    \n    {\\displaystyle {\\mathcal {H}}.}\n  \n\n\n== The relation between Occam and PAC learning ==\nOccam learnability implies PAC learnability, as the following theorem of Blumer, et al. shows:\n\n\n=== Theorem (Occam learning implies PAC learning) ===\nLet \n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n   be an efficient  \n  \n    \n      \n        (\n        \u03b1\n        ,\n        \u03b2\n        )\n      \n    \n    {\\displaystyle (\\alpha ,\\beta )}\n  -Occam algorithm for \n  \n    \n      \n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {C}}}\n   using \n  \n    \n      \n        \n          \n            H\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {H}}}\n  . Then there exists a constant \n  \n    \n      \n        a\n        >\n        0\n      \n    \n    {\\displaystyle a>0}\n   such that for any \n  \n    \n      \n        0\n        <\n        \u03f5\n        ,\n        \u03b4\n        <\n        1\n      \n    \n    {\\displaystyle 0<\\epsilon ,\\delta <1}\n  , for any distribution \n  \n    \n      \n        \n          \n            D\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {D}}}\n  , given \n  \n    \n      \n        m\n        \u2265\n        a\n        \n          (\n          \n            \n              \n                1\n                \u03f5\n              \n            \n            log\n            \u2061\n            \n              \n                1\n                \u03b4\n              \n            \n            +\n            \n              \n                (\n                \n                  \n                    \n                      (\n                      n\n                      \u22c5\n                      s\n                      i\n                      z\n                      e\n                      (\n                      c\n                      )\n                      \n                        )\n                        \n                          \u03b1\n                        \n                      \n                      )\n                    \n                    \u03f5\n                  \n                \n                )\n              \n              \n                \n                  1\n                  \n                    1\n                    \u2212\n                    \u03b2\n                  \n                \n              \n            \n          \n          )\n        \n      \n    \n    {\\displaystyle m\\geq a\\left({\\frac {1}{\\epsilon }}\\log {\\frac {1}{\\delta }}+\\left({\\frac {(n\\cdot size(c))^{\\alpha })}{\\epsilon }}\\right)^{\\frac {1}{1-\\beta }}\\right)}\n    samples drawn from \n  \n    \n      \n        \n          \n            D\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {D}}}\n   and labelled according to a concept \n  \n    \n      \n        c\n        \u2208\n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle c\\in {\\mathcal {C}}}\n   of length \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n   bits each, the algorithm  \n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n   will output a hypothesis  \n  \n    \n      \n        h\n        \u2208\n        \n          \n            H\n          \n        \n      \n    \n    {\\displaystyle h\\in {\\mathcal {H}}}\n   such that \n  \n    \n      \n        e\n        r\n        r\n        o\n        r\n        (\n        h\n        )\n        \u2264\n        \u03f5\n      \n    \n    {\\displaystyle error(h)\\leq \\epsilon }\n   with probability at least \n  \n    \n      \n        1\n        \u2212\n        \u03b4\n      \n    \n    {\\displaystyle 1-\\delta }\n   .Here, \n  \n    \n      \n        e\n        r\n        r\n        o\n        r\n        (\n        h\n        )\n      \n    \n    {\\displaystyle error(h)}\n   is with respect to the concept \n  \n    \n      \n        c\n      \n    \n    {\\displaystyle c}\n   and distribution \n  \n    \n      \n        \n          \n            D\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {D}}}\n  . This implies that the algorithm \n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n   is also a PAC learner for the concept class \n  \n    \n      \n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {C}}}\n   using hypothesis class \n  \n    \n      \n        \n          \n            H\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {H}}}\n  .  A slightly more general formulation is as follows:\n\n\n=== Theorem (Occam learning implies PAC learning, cardinality version) ===\nLet \n  \n    \n      \n        0\n        <\n        \u03f5\n        ,\n        \u03b4\n        <\n        1\n      \n    \n    {\\displaystyle 0<\\epsilon ,\\delta <1}\n  . Let \n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n   be an algorithm such that, given \n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n   samples drawn from a fixed but unknown distribution \n  \n    \n      \n        \n          \n            D\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {D}}}\n   and labeled according to a concept \n  \n    \n      \n        c\n        \u2208\n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle c\\in {\\mathcal {C}}}\n   of length \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n   bits each, outputs a hypothesis \n  \n    \n      \n        h\n        \u2208\n        \n          \n            \n              H\n            \n          \n          \n            n\n            ,\n            m\n          \n        \n      \n    \n    {\\displaystyle h\\in {\\mathcal {H}}_{n,m}}\n   that is consistent with the labeled samples. Then, there exists a constant \n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n   such that if \n  \n    \n      \n        log\n        \u2061\n        \n          |\n        \n        \n          \n            \n              H\n            \n          \n          \n            n\n            ,\n            m\n          \n        \n        \n          |\n        \n        \u2264\n        b\n        \u03f5\n        m\n        \u2212\n        log\n        \u2061\n        \n          \n            1\n            \u03b4\n          \n        \n      \n    \n    {\\displaystyle \\log |{\\mathcal {H}}_{n,m}|\\leq b\\epsilon m-\\log {\\frac {1}{\\delta }}}\n  , then \n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n    is guaranteed to output a hypothesis \n  \n    \n      \n        h\n        \u2208\n        \n          \n            \n              H\n            \n          \n          \n            n\n            ,\n            m\n          \n        \n      \n    \n    {\\displaystyle h\\in {\\mathcal {H}}_{n,m}}\n   such that \n  \n    \n      \n        e\n        r\n        r\n        o\n        r\n        (\n        h\n        )\n        \u2264\n        \u03f5\n      \n    \n    {\\displaystyle error(h)\\leq \\epsilon }\n   with probability at least \n  \n    \n      \n        1\n        \u2212\n        \u03b4\n      \n    \n    {\\displaystyle 1-\\delta }\n  .\nWhile the above theorems show that Occam learning is sufficient for PAC learning, it doesn't say anything about necessity. Board and Pitt show that, for a wide variety of concept classes, Occam learning is in fact necessary for PAC learning. They proved that for any concept class that is polynomially closed under exception lists, PAC learnability implies the existence of an Occam algorithm for that concept class. Concept classes that are polynomially closed under exception lists include Boolean formulas, circuits, deterministic finite automata, decision-lists, decision-trees, and other geometrically-defined concept classes.\nA concept class \n  \n    \n      \n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {C}}}\n   is polynomially closed under exception lists if there exists a polynomial-time algorithm \n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n   such that, when given the representation of a concept \n  \n    \n      \n        c\n        \u2208\n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle c\\in {\\mathcal {C}}}\n   and a finite list \n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n   of exceptions, outputs a representation of a concept \n  \n    \n      \n        \n          c\n          \u2032\n        \n        \u2208\n        \n          \n            C\n          \n        \n      \n    \n    {\\displaystyle c'\\in {\\mathcal {C}}}\n   such that the concepts \n  \n    \n      \n        c\n      \n    \n    {\\displaystyle c}\n   and \n  \n    \n      \n        \n          c\n          \u2032\n        \n      \n    \n    {\\displaystyle c'}\n   agree except on the set \n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n  .\n\n\n== Proof that Occam learning implies PAC learning ==\nWe first prove the Cardinality version. Call a hypothesis \n  \n    \n      \n        h\n        \u2208\n        \n          \n            H\n          \n        \n      \n    \n    {\\displaystyle h\\in {\\mathcal {H}}}\n   bad if \n  \n    \n      \n        e\n        r\n        r\n        o\n        r\n        (\n        h\n        )\n        \u2265\n        \u03f5\n      \n    \n    {\\displaystyle error(h)\\geq \\epsilon }\n  , where again \n  \n    \n      \n        e\n        r\n        r\n        o\n        r\n        (\n        h\n        )\n      \n    \n    {\\displaystyle error(h)}\n   is with respect to the true concept \n  \n    \n      \n        c\n      \n    \n    {\\displaystyle c}\n   and the underlying distribution \n  \n    \n      \n        \n          \n            D\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {D}}}\n  . The probability that a set of samples \n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n   is consistent with \n  \n    \n      \n        h\n      \n    \n    {\\displaystyle h}\n   is at most \n  \n    \n      \n        (\n        1\n        \u2212\n        \u03f5\n        \n          )\n          \n            m\n          \n        \n      \n    \n    {\\displaystyle (1-\\epsilon )^{m}}\n  , by the independence of the samples. By the union bound, the probability that there exists a bad hypothesis in \n  \n    \n      \n        \n          \n            \n              H\n            \n          \n          \n            n\n            ,\n            m\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {H}}_{n,m}}\n   is at most \n  \n    \n      \n        \n          |\n        \n        \n          \n            \n              H\n            \n          \n          \n            n\n            ,\n            m\n          \n        \n        \n          |\n        \n        (\n        1\n        \u2212\n        \u03f5\n        \n          )\n          \n            m\n          \n        \n      \n    \n    {\\displaystyle |{\\mathcal {H}}_{n,m}|(1-\\epsilon )^{m}}\n  , which is less than \n  \n    \n      \n        \u03b4\n      \n    \n    {\\displaystyle \\delta }\n   if \n  \n    \n      \n        log\n        \u2061\n        \n          |\n        \n        \n          \n            \n              H\n            \n          \n          \n            n\n            ,\n            m\n          \n        \n        \n          |\n        \n        \u2264\n        O\n        (\n        \u03f5\n        m\n        )\n        \u2212\n        log\n        \u2061\n        \n          \n            1\n            \u03b4\n          \n        \n      \n    \n    {\\displaystyle \\log |{\\mathcal {H}}_{n,m}|\\leq O(\\epsilon m)-\\log {\\frac {1}{\\delta }}}\n  . This concludes the proof of the second theorem above.\nUsing the second theorem, we can prove the first theorem. Since we have a \n  \n    \n      \n        (\n        \u03b1\n        ,\n        \u03b2\n        )\n      \n    \n    {\\displaystyle (\\alpha ,\\beta )}\n  -Occam algorithm, this means that any hypothesis output by \n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n   can be represented by at most \n  \n    \n      \n        (\n        n\n        \u22c5\n        s\n        i\n        z\n        e\n        (\n        c\n        )\n        \n          )\n          \n            \u03b1\n          \n        \n        \n          m\n          \n            \u03b2\n          \n        \n      \n    \n    {\\displaystyle (n\\cdot size(c))^{\\alpha }m^{\\beta }}\n   bits, and thus \n  \n    \n      \n        log\n        \u2061\n        \n          |\n        \n        \n          \n            \n              H\n            \n          \n          \n            n\n            ,\n            m\n          \n        \n        \n          |\n        \n        \u2264\n        (\n        n\n        \u22c5\n        s\n        i\n        z\n        e\n        (\n        c\n        )\n        \n          )\n          \n            \u03b1\n          \n        \n        \n          m\n          \n            \u03b2\n          \n        \n      \n    \n    {\\displaystyle \\log |{\\mathcal {H}}_{n,m}|\\leq (n\\cdot size(c))^{\\alpha }m^{\\beta }}\n  . This is less than \n  \n    \n      \n        O\n        (\n        \u03f5\n        m\n        )\n        \u2212\n        log\n        \u2061\n        \n          \n            1\n            \u03b4\n          \n        \n      \n    \n    {\\displaystyle O(\\epsilon m)-\\log {\\frac {1}{\\delta }}}\n   if we set \n  \n    \n      \n        m\n        \u2265\n        a\n        \n          (\n          \n            \n              \n                1\n                \u03f5\n              \n            \n            log\n            \u2061\n            \n              \n                1\n                \u03b4\n              \n            \n            +\n            \n              \n                (\n                \n                  \n                    \n                      (\n                      n\n                      \u22c5\n                      s\n                      i\n                      z\n                      e\n                      (\n                      c\n                      )\n                      \n                        )\n                        \n                          \u03b1\n                        \n                      \n                      )\n                    \n                    \u03f5\n                  \n                \n                )\n              \n              \n                \n                  1\n                  \n                    1\n                    \u2212\n                    \u03b2\n                  \n                \n              \n            \n          \n          )\n        \n      \n    \n    {\\displaystyle m\\geq a\\left({\\frac {1}{\\epsilon }}\\log {\\frac {1}{\\delta }}+\\left({\\frac {(n\\cdot size(c))^{\\alpha })}{\\epsilon }}\\right)^{\\frac {1}{1-\\beta }}\\right)}\n   for some constant \n  \n    \n      \n        a\n        >\n        0\n      \n    \n    {\\displaystyle a>0}\n  . Thus, by the Cardinality version Theorem, \n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n   will output a consistent hypothesis \n  \n    \n      \n        h\n      \n    \n    {\\displaystyle h}\n   with probability at least \n  \n    \n      \n        1\n        \u2212\n        \u03b4\n      \n    \n    {\\displaystyle 1-\\delta }\n  . This concludes the proof of the first theorem above.\n\n\n== Improving sample complexity for common problems ==\nThough Occam and PAC learnability are equivalent, the Occam framework can be used to produce tighter bounds on the sample complexity of classical problems including conjunctions, conjunctions with few relevant variables, and decision lists.\n\n\n== Extensions ==\nOccam algorithms have also been shown to be successful for PAC learning in the presence of errors, probabilistic concepts, function learning and Markovian non-independent examples.\n\n\n== See also ==\nStructural Risk Minimization\nComputational learning theory\n\n\n== References ==