In statistics, Markov chain Monte Carlo (MCMC) methods comprise a class of algorithms for sampling from a probability distribution. By constructing a Markov chain that has the desired distribution as its equilibrium distribution, one can obtain a sample of the desired distribution by recording states from the chain. The more steps that are included, the more closely the distribution of the sample matches the actual desired distribution. Various algorithms exist for constructing chains, including the Metropolis\u2013Hastings algorithm.\n\n\n== Application domains ==\nMCMC methods are primarily used for calculating numerical approximations of multi-dimensional integrals, for example in Bayesian statistics, computational physics, computational biology and computational linguistics.In Bayesian statistics, the recent development of MCMC methods has made it possible to compute large hierarchical models that require integrations over hundreds to thousands of unknown parameters.In rare event sampling, they are also used for generating samples that gradually populate the rare failure region.\n\n\n== General explanation ==\n\nMarkov chain Monte Carlo methods create samples from a continuous random variable, with probability density proportional to a known function. These samples can be used to evaluate an integral over that variable, as its expected value or variance.\nPractically, an ensemble of chains is generally developed, starting from a set of points arbitrarily chosen and sufficiently distant from each other. These chains are stochastic processes of "walkers" which move around randomly according to an algorithm that looks for places with a reasonably high contribution to the integral to move into next, assigning them higher probabilities.\nRandom walk Monte Carlo methods are a kind of random simulation or Monte Carlo method. However, whereas the random samples of the integrand used in a conventional Monte Carlo integration are statistically independent, those used in MCMC are autocorrelated. Correlations of samples introduces the need to use the Markov chain central limit theorem when estimating the error of mean values.\nThese algorithms create Markov chains such that they have an equilibrium distribution which is proportional to the function given.\n\n\n== Reducing correlation ==\nWhile MCMC methods were created to address multi-dimensional problems better than generic Monte Carlo algorithms, when the number of dimensions rises they too tend to suffer the curse of dimensionality: regions of higher probability tend to stretch and get lost in an increasing volume of space that contributes little to the integral. One way to address this problem could be shortening the steps of the walker, so that it doesn't continuously try to exit the highest probability region, though this way the process would be highly autocorrelated and expensive (i.e. many steps would be required for an accurate result). More sophisticated methods such as Hamiltonian Monte Carlo and the Wang and Landau algorithm use various ways of reducing this autocorrelation, while managing to keep the process in the regions that give a higher contribution to the integral. These algorithms usually rely on a more complicated theory and are harder to implement, but they usually converge faster.\n\n\n== Examples ==\n\n\n=== Random walk ===\nMetropolis\u2013Hastings algorithm: This method generates a Markov chain using a proposal density for new steps and a method for rejecting some of the proposed moves. It is actually a general framework which includes as special cases the very first and simpler MCMC (Metropolis algorithm) and many more recent alternatives listed below.\nGibbs sampling: This method requires all the conditional distributions of the target distribution to be sampled exactly. When drawing from the full-conditional distributions is not straightforward other samplers-within-Gibbs are used (e.g., see ). Gibbs sampling is popular partly because it does not require any 'tuning'.\nMetropolis-adjusted Langevin algorithm and other methods that rely on the gradient (and possibly second derivative) of the log target density to propose steps that are more likely to be in the direction of higher probability density.\nPseudo-marginal Metropolis\u2013Hastings: This method replaces the evaluation of the density of the target distribution with an unbiased estimate and is useful when the target density is not available analytically, e.g. latent variable models.\nSlice sampling: This method depends on the principle that one can sample from a distribution by sampling uniformly from the region under the plot of its density function.  It alternates uniform sampling in the vertical direction with uniform sampling from the horizontal 'slice' defined by the current vertical position.\nMultiple-try Metropolis: This method is a variation of the Metropolis\u2013Hastings algorithm that allows multiple trials at each point. By making it possible to take larger steps at each iteration, it helps address the curse of dimensionality.\nReversible-jump: This method is a variant of the Metropolis\u2013Hastings algorithm that allows proposals that change the dimensionality of the space.  Markov chain Monte Carlo methods that change dimensionality have long been used in statistical physics applications, where for some problems a distribution that is a grand canonical ensemble is used (e.g., when the number of molecules in a box is variable).  But the reversible-jump variant is useful when doing Markov chain Monte Carlo or Gibbs sampling over nonparametric Bayesian models such as those involving the Dirichlet process or Chinese restaurant process, where the number of mixing components/clusters/etc. is automatically inferred from the data.\nHamiltonian (or Hybrid) Monte Carlo (HMC): Tries to avoid random walk behaviour by introducing an auxiliary momentum vector and implementing Hamiltonian dynamics, so the potential energy function is the target density. The momentum samples are discarded after sampling. The end result of Hybrid Monte Carlo is that proposals move across the sample space in larger steps; they are therefore less correlated and converge to the target distribution more rapidly.\n\n\n=== Interacting particle methods ===\nInteracting MCMC methodologies are a class of mean field particle methods for obtaining random samples from a sequence of probability distributions with an increasing level of sampling complexity. These probabilistic models include path space state models with increasing time horizon, posterior distributions w.r.t. sequence of partial observations, increasing constraint level sets for conditional distributions, decreasing temperature schedules associated with some Boltzmann-Gibbs distributions, and many others. In principle, any Markov chain Monte Carlo sampler can be turned into an interacting Markov chain Monte Carlo sampler. These interacting Markov chain Monte Carlo samplers can be interpreted as a way to run in parallel a sequence of Markov chain Monte Carlo samplers. For instance, interacting simulated annealing algorithms are based on independent Metropolis-Hastings moves interacting sequentially with a selection-resampling type mechanism. In contrast to traditional Markov chain Monte Carlo methods, the precision parameter of this class of interacting Markov chain Monte Carlo samplers is only related to the number of interacting Markov chain Monte Carlo samplers. These advanced particle methodologies belong to the class of Feynman-Kac particle models,  also called Sequential Monte Carlo or particle filter methods in Bayesian inference and signal processing communities. Interacting Markov chain Monte Carlo methods can also be interpreted as a mutation-selection genetic particle algorithm with Markov chain Monte Carlo mutations.\n\n\n=== Markov Chain quasi-Monte Carlo (MCQMC). ===\nThe advantage of low-discrepancy sequences in lieu of random numbers for simple independent Monte Carlo sampling is well known. This procedure, known as Quasi-Monte Carlo method (QMC), yields an integration error that decays at a superior rate to that obtained by IID sampling, by the Koksma-Hlawka inequality. Empirically it allows the reduction of both estimation error and convergence time by an order of magnitude. The Array-RQMC method combines randomized quasi-Monte Carlo and Markov chain simulation by simulating \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n   chains simultaneously in a way that the empirical distribution of the \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n   states at any given step is a better approximation of the true distribution of the chain than with ordinary MCMC. In empirical experiments, the variance of the average of a function of the state sometimes converges at rate \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            \u2212\n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{-2})}\n   or even faster, instead of the \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            \u2212\n            1\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{-1})}\n   Monte Carlo rate.\n\n\n== Convergence ==\nUsually it is not hard to construct a Markov chain with the desired properties. The more difficult problem is to determine how many steps are needed to converge to the stationary distribution within an acceptable error. A good chain will have rapid mixing: the stationary distribution is reached quickly starting from an arbitrary position. A standard empirical method to assess convergence is to run several independent simulated Markov chains and check that the ratio of inter-chain to intra-chain variances for all the parameters sampled is close to 1.Typically, Markov chain Monte Carlo sampling can only approximate the target distribution, as there is always some residual effect of the starting position. More sophisticated Markov chain Monte Carlo-based algorithms such as coupling from the past can produce exact samples, at the cost of additional computation and an unbounded (though finite in expectation) running time.\nMany random walk Monte Carlo methods move around the equilibrium distribution in relatively small steps, with no tendency for the steps to proceed in the same direction. These methods are easy to implement and analyze, but unfortunately it can take a long time for the walker to explore all of the space. The walker will often double back and cover ground already covered.\nFurther consideration of convergence is at Markov chain central limit theorem. See  for a discussion of the theory related to convergence and stationarity of the Metropolis-Hastings algorithm.\n\n\n== Software ==\nSeveral software programs provide MCMC sampling capabilities, for example:\n\nParaMonte, a high-performance serial / parallel software for Monte Carlo simulations, including the Delayed-Rejection Adaptive Metropolis-Hastings MCMC, available in\nPython,\nMATLAB,\nC / C++ / Fortran on Windows, Linux, and macOS.\nPackages that use dialects of the BUGS model language:\nWinBUGS / OpenBUGS/ MultiBUGS\nJAGS\nNIMBLE\ngreta, a Bayesian statistical modeling language / R package which uses TensorFlow behind the scenes, similar to PyMC3's use of Theano as the computational back-end\nMCSim\nPyMC3\npymcmcstat\nR (programming language) with the packages adaptMCMC, atmcmc, BRugs, mcmc, MCMCpack, ramcmc, rjags, rstan, etc.\nStan\nTensorFlow Probability (probabilistic programming library built on TensorFlow)\nMCL (a cluster algorithm for graphs) and HipMCL (a parallelized version)\nemcee (MIT licensed pure-Python implementation of Goodman & Weare's Affine Invariant Markov chain Monte Carlo Ensemble sampler)\nKeanu a general-purpose probabilistic programming library built in Java\nZeus is a pure-Python implementation of the Ensemble Slice Sampling method\nTuring.jl, a package for general-purpose probabilistic programming in Julia\nMamba.jl, a platform for MCMC method in Julia\n\n\n== See also ==\nCoupling from the past\nMetropolis-adjusted Langevin algorithm\nMarkov chain central limit theorem\n\n\n== References ==\n\n\n=== Citations ===\n\n\n=== Sources ===\n\n\n== Further reading ==\n\n\n== External links ==\nMCMC sampling and other methods in a basic overview, by Alexander Mantzaris (original link - now broken)\nPyMC - Python module implementing Bayesian statistical models and fitting algorithms, including Markov chain Monte Carlo.\nIA2RMS is a Matlab code of the "Independent Doubly Adaptive Rejection Metropolis Sampling" method, Martino, Read & Luengo (2015), for drawing from the full-conditional densities within a Gibbs sampler.